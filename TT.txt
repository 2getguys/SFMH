
Зрозуміло. Отже, зупиняємось на **TypeScript/JavaScript (Node.js)**. Це чудовий вибір, враховуючи велику екосистему, підтримку SDK для OpenAI та Supabase, а також зручність асинхронного програмування.

Дякую за уточнення щодо ще одного рівня вкладеності агентів! Тепер я бачу, що агент `sfmh_base` (агент бази даних) для перевірки наявності товару (`crm_available` в його інструментах) фактично викликає інший, менший агент, який вже безпосередньо взаємодіє з KeyCRM через HTTP запит. Цей "агент наявності" отримує `product_id` і перевіряє поле `quantity`.

Це важлива деталь, яка впливає на архітектуру взаємодії.

Давайте оновимо наше **Технічне Завдання (ТЗ)**, враховуючи це:

1.  **Загальний опис системи та мета:** (Залишається без змін наразі)
2.  **Архітектура:**
    *   Мова програмування: **TypeScript** (з Node.js).
    *   Структура проекту: Базується на `instagram-dm-agent/src/...` (як надано на скріншоті).
3.  **Компоненти системи:**
    *   **Головний Агент (Леголас):**
        *   Призначення, основна логіка (детальний промпт з n8n, методологія AIDA).
        *   Вхідні/вихідні дані (повідомлення користувача / відповіді для Instagram).
        *   Інструменти:
            *   Інтеграція з CRM для запису замовлень (`CRM_Orders` -> Supabase).
            *   Виклик **Субагента Бази Даних (`sfmh_base`)** для інформації про товари.
        *   Управління пам'яттю (PostgreSQL, `n8n_directBot` таблиця, контекст на 10 повідомлень).
        *   Логіка обробки та розбиття довгих повідомлень (через виклик **Агента Розбиття Повідомлень**).
    *   **Субагент Бази Даних (`sfmh_base`):**
        *   Призначення: Надання структурованої інформації про товари Головному Агенту.
        *   Основна логіка (промпт з n8n: пошук в базі, не спілкується з клієнтом, повертає повну необроблену інформацію).
        *   Вхідні/вихідні дані (запит від Головного Агента / структуровані дані про товар).
        *   Інструменти:
            *   Векторний пошук товарів (`catalog_sfmh` в Supabase).
            *   Пошук товару за ID (`sfmh_ids` таблиця в Supabase).
            *   Виклик **Субагента Перевірки Наявності (`crm_available`)** для даних про залишки.
    *   **Субагент Перевірки Наявності (`crm_available`):**
        *   Призначення: Перевірка наявності товару в KeyCRM.
        *   Основна логіка (промпт з n8n: отримати product_id, зробити запит до KeyCRM, відповісти про наявність).
        *   Вхідні/вихідні дані (product_id / повідомлення про наявність).
        *   Інструменти: HTTP запит до KeyCRM API.
    *   **Агент Розбиття Повідомлень (якщо відповідь Головного Агента > 1000 символів):**
        *   Призначення: Логічне розбиття довгого тексту на частини.
        *   Основна логіка (промпт з n8n: повернути JSON з частинами повідомлення).
        *   Вхідні/вихідні дані (довгий текст / JSON з масивом частин).
        *   Використовує OpenAI модель.
    *   **Сервіси:**
        *   **Instagram API:** Отримання повідомлень (вебхук), відправка повідомлень.
        *   **Supabase:**
            *   Клієнт для підключення.
            *   Векторний пошук (`pgvector` для `catalog_sfmh`).
            *   CRUD для `INSTA_Orders_CRM` та `sfmh_ids`.
        *   **PostgreSQL (для пам'яті чату):** Збереження/отримання історії діалогів (`n8n_directBot`).
        *   **OpenAI API:** Взаємодія для всіх агентів.
        *   **KeyCRM API:** HTTP запити для перевірки наявності.
    *   **Утиліти:**
        *   Очищення тексту (видалення спецсимволів).
        *   Логування.
        *   Обробка та валідація змінних середовища (`env.ts`, `constants.ts`).
    *   **API Layer:**
        *   Вхідна точка (`index.ts`).
        *   Вебхук для Instagram (`/insta-dm`).
        *   Маршрутизація, middleware, контролери (згідно структури `src/api/...`).
4.  **Ключові сценарії використання:** (Залишається без змін наразі)
5.  **Технічні вимоги:**
    *   Мова: TypeScript.
    *   Середовище виконання: Node.js.
    *   Основні бібліотеки (попередній список, можемо доповнювати):
        *   `openai` (для взаємодії з GPT).
        *   `@supabase/supabase-js` (для Supabase).
        *   `pg` (для PostgreSQL).
        *   Framework для API (наприклад, Express.js, Fastify, або вбудований Node.js `http`).
        *   Бібліотека для валідації (наприклад, Zod, Joi).
        *   Бібліотека для логування (наприклад, Winston, Pino).
    *   Змінні середовища для ключів API, підключень до баз даних.
6.  **Відкриті питання та моменти для уточнення:**
    *   Як саме планується реалізувати "виклики" між агентами? Це будуть прямі виклики функцій/класів, чи якась форма внутрішніх HTTP запитів, чи використання черги повідомлень? В n8n це "Execute Workflow", що схоже на асинхронний виклик.
    *   Формат відповіді від Агента Розбиття Повідомлень (в n8n вказано `{"messages": {"parts": "text 1", "parts": "text 2"}}`, що не є валідним JSON для кількох частин. Ймовірно, має бути масив: `{"messages": {"parts": ["text 1", "text 2"]}}` або `{"message_parts": ["text 1", "text 2"]}`).
    *   Деталі реалізації векторного пошуку (які поля індексуються, як формується запит).
    *   Специфікація полів для `INSTA_Orders_CRM`.

Ця оновлена структура ТЗ виглядає більш повною. Готові перейти до обговорення перших кроків реалізації або деталізації якогось конкретного компонента? Наприклад, ми могли б почати з налаштування базової структури проекту, підключення до OpenAI та Supabase, або з реалізації першого вебхука для Instagram.
